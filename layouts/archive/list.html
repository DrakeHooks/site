<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>archive</title>
  <meta name="format-detection" content="telephone=no, date=no, address=no, email=no" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    * { box-sizing: border-box; }

    :root{
      --left-gutter: 36px;
      --right-gutter: 96px;
      --content-pad: 24px;

      --mobile-side-pad: 14px;
      --mobile-top-pad: 12px;
      --icon-size: 26px;
      --mobile-icon-gap: 10px;

      /* Calm fade */
      --fade-duration: 1800ms;
      --fade-ease: cubic-bezier(0.10, 1, 0.3, 1);
      --fade-start: 0;
      --fade-min-delay: 120ms;
      --fade-stagger: 70ms;
      --fade-stagger-cap: 700ms;

      /* Optional perf */
      --cv-intrinsic-h: 900px;
      --use-content-visibility: 0; /* default OFF for Safari-first load speed */
    }

    body{
      font-family: Arial, Helvetica, sans-serif;
      font-size: 11px;
      margin: 0;
      background: #fff;
      color: #000;
      overflow-x: hidden;
    }

    .home-icon{
      width: var(--icon-size);
      height: var(--icon-size);
      opacity: 0.95;
      -webkit-tap-highlight-color: transparent;
      display: inline-block;
    }
    .home-icon img{ width: 100%; height: auto; display: block; }
    .home-icon:hover{ opacity: 1; }

    .mobile-top{
      position: relative;
      padding: var(--mobile-top-pad) var(--mobile-side-pad);
      height: calc(var(--icon-size) + (var(--mobile-top-pad) * 2));
    }
    .home-icon--mobile{
      position: absolute;
      top: var(--mobile-top-pad);
      left: calc(env(safe-area-inset-left) + var(--mobile-side-pad));
    }
    .home-icon--desktop{
      position: fixed;
      top: 16px;
      left: 8px;
      z-index: 1000;
    }
    @media (min-width: 901px){ .mobile-top{ display:none; } }
    @media (max-width: 900px){ .home-icon--desktop{ display:none; } }

    .content{
      margin: 0 auto;
      max-width: 700px;
      padding: 0 var(--mobile-side-pad) 2rem;
    }
    @media (max-width: 900px){ .content{ padding-top: var(--mobile-icon-gap); } }
    @media (min-width: 900px){
      .content{ margin:0; max-width:none; padding: var(--content-pad); margin-left: var(--left-gutter); }
    }

    .full-post-block{
      margin-bottom: 4rem;
      contain: layout paint;
    }

    @media (max-width: 900px){
      @supports (content-visibility: auto){
        html.cv-on .full-post-block{
          content-visibility: auto;
          contain-intrinsic-size: 1px var(--cv-intrinsic-h);
        }
      }
    }

    .date{ font-size: 11px; margin-bottom: .5rem; }

    .post img, figure img{
      max-width: 100%;
      height: auto;
      margin-top: 1rem;
      display: block;

      opacity: var(--fade-start);
      transition: opacity var(--fade-duration) var(--fade-ease);
      transition-delay: var(--fade-delay, 0ms);

      dynamic-range-limit: standard;
    }
    img.reveal{ opacity: 1; }
    img.broken{ opacity: 1; filter: grayscale(1); }

    figure{ margin: 1rem 0; padding: 0; contain: layout paint; }
    .figure-row{ display:flex; gap:1rem; flex-wrap:wrap; margin:1rem 0 2rem; contain: layout paint; }
    .figure-row figure{ flex:1 1 30%; margin:0; }
    .figure-row img{ width:100%; height:auto; object-fit:cover; display:block; }

    @media (min-width: 900px){
      .full-post-block{
        width: calc(100vw - var(--left-gutter) - var(--right-gutter));
        max-width: calc(100vw - var(--left-gutter) - var(--right-gutter));
      }
      .full-post-block > figure,
      .full-post-block p,
      .full-post-block .date{ width:100%; max-width:100%; }
    }

    .month-block{ margin-bottom: 3rem; }
    .month-header{
      background:none; border:none;
      padding: .5rem 0;
      font-size: .8rem;
      text-align:left;
      cursor:pointer;
      color:#000;
      width:100%;
      -webkit-tap-highlight-color: transparent;
    }
    .month-header::before{
      content:"▸ ";
      display:inline-block;
      transition: transform .2s ease;
    }
    .month-block.expanded .month-header::before{ transform: rotate(90deg); }
    .month-content{ margin-top: .75rem; }
    .month-block.collapsed .month-content{ display:none; }

    @media (prefers-reduced-motion: reduce){
      .post img, figure img { transition:none; opacity: 1; }
    }
  </style>
</head>

<body>
  <div class="mobile-top">
    <a class="home-icon home-icon--mobile" href="https://drakehooks.net" aria-label="Home">
      <img src="/drawing.svg" alt="">
    </a>
  </div>

  <a class="home-icon home-icon--desktop" href="https://drakehooks.net" aria-label="Home">
    <img src="/drawing.svg" alt="">
  </a>

  <div class="content">
    {{ range $idx, $month := .Pages.ByDate.Reverse.GroupByDate "01 2006" }}
      <section class="month-block {{ if eq $idx 0 }}expanded{{ else }}collapsed{{ end }}">
        <button class="month-header" type="button">{{ $month.Key }}</button>
        <div class="month-content">
          {{ range $month.Pages.ByDate.Reverse }}
            <div class="full-post-block">
              <div class="date">{{ .Date.Format "01 02 2006" }}</div>
              {{ .Content }}
            </div>
          {{ end }}
        </div>
      </section>
    {{ end }}
  </div>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const root = document.documentElement;
      const css  = getComputedStyle(root);

      // Safari-first: content-visibility OFF by default (can delay/oddly interact with loading/IO on iOS)
      const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      const useCV = !isSafari && (parseFloat(css.getPropertyValue("--use-content-visibility")) || 0) > 0;
      if (useCV) root.classList.add("cv-on");

      const MIN_DELAY = parseInt(css.getPropertyValue("--fade-min-delay")) || 120;
      const STEP      = parseInt(css.getPropertyValue("--fade-stagger")) || 70;
      const CAP       = parseInt(css.getPropertyValue("--fade-stagger-cap")) || 700;

      // --------- Key Safari load strategy ----------
      // Promote only a tight window ahead so Safari's limited concurrent requests are spent wisely.
      const LOAD_MARGIN   = "1400px 0px"; // start fetch ~1–2 screens ahead
      const REVEAL_MARGIN = "220px 0px";  // fade near viewport
      const PROMOTE_CAP   = 80;           // do NOT exceed; too many hurts Safari
      const TOP_EAGER     = 10;           // immediate eager/high in opened month

      // Reveal gating (FPS)
      const SCROLL_DEBOUNCE = 110;
      const REVEAL_BATCH = 10;

      let scrolling = false, t = 0;
      window.addEventListener("scroll", () => {
        scrolling = true;
        clearTimeout(t);
        t = setTimeout(() => { scrolling = false; pumpReveal(); }, SCROLL_DEBOUNCE);
      }, { passive: true });

      function markBroken(img){ img.classList.add("broken"); }

      // Reveal queue
      const rq = [];
      const rs = new Set();
      let pumping = false;

      function enqueueReveal(img){
        if (!img || img.classList.contains("reveal") || img.classList.contains("broken")) return;
        if (rs.has(img)) return;
        rs.add(img); rq.push(img);
        if (!scrolling) pumpReveal();
      }

      function pumpReveal(){
        if (pumping || scrolling || rq.length === 0) return;
        pumping = true;
        requestAnimationFrame(() => {
          const n = Math.min(REVEAL_BATCH, rq.length);
          for (let i = 0; i < n; i++){
            const img = rq.shift();
            rs.delete(img);
            const d = MIN_DELAY + Math.min(i * STEP, CAP);
            img.style.setProperty("--fade-delay", d + "ms");
            img.classList.add("reveal");
          }
          pumping = false;
          if (rq.length) setTimeout(pumpReveal, 0);
        });
      }

      // Promote control
      let promoted = 0;
      function promote(img){
        if (!img || img.dataset.p === "1") return;
        img.dataset.p = "1";
        promoted++;
        img.setAttribute("loading", "eager");
        img.setAttribute("decoding", "async");
        if (!img.hasAttribute("fetchpriority")) img.setAttribute("fetchpriority", "high");
        if (!img.hasAttribute("importance")) img.setAttribute("importance", "high");
      }

      function base(img){
        if (!img.hasAttribute("decoding")) img.setAttribute("decoding", "async");
        if (!img.hasAttribute("loading")) img.setAttribute("loading", "lazy");
      }

      // Observers
      const loadIO = new IntersectionObserver((entries) => {
        for (const e of entries){
          if (!e.isIntersecting) continue;
          const img = e.target;
          loadIO.unobserve(img);

          // Hard cap avoids "preload too much -> everything waits"
          if (promoted < PROMOTE_CAP) promote(img);

          // If it’s already complete and near-ish, it can reveal once revealIO hits
        }
      }, { root: null, rootMargin: LOAD_MARGIN, threshold: 0.01 });

      const revealIO = new IntersectionObserver((entries) => {
        for (const e of entries){
          if (!e.isIntersecting) continue;
          const img = e.target;
          revealIO.unobserve(img);
          img.dataset.near = "1";

          // Ensure near-view always promoted (even if cap reached)
          promote(img);

          if (img.complete){
            if (img.naturalWidth === 0) { markBroken(img); continue; }
            enqueueReveal(img);
          }
        }
      }, { root: null, rootMargin: REVEAL_MARGIN, threshold: 0.01 });

      function attach(img){
        if (img.dataset.h === "1") return;
        img.dataset.h = "1";

        img.addEventListener("load", () => {
          if (img.naturalWidth === 0) { markBroken(img); return; }
          if (img.dataset.near === "1") enqueueReveal(img);
        }, { passive: true });

        img.addEventListener("error", () => markBroken(img), { passive: true });
      }

      function observeMonth(block){
        promoted = 0; // reset per opened month (important!)
        const imgs = block.querySelectorAll("img");

        for (let i = 0; i < imgs.length; i++){
          const img = imgs[i];
          base(img);
          attach(img);

          img.classList.remove("reveal");
          img.style.removeProperty("--fade-delay");
          img.dataset.near = "0";

          // Make the top chunk instant
          if (i < TOP_EAGER) promote(img);

          loadIO.observe(img);
          revealIO.observe(img);
        }
      }

      // Initial expanded month
      const first = document.querySelector(".month-block.expanded");
      if (first) observeMonth(first);

      // Toggle
      document.addEventListener("click", (e) => {
        const header = e.target.closest(".month-header");
        if (!header) return;
        const block = header.closest(".month-block");
        if (!block) return;

        const expanding = block.classList.contains("collapsed");
        block.classList.toggle("collapsed");
        block.classList.toggle("expanded");
        if (expanding) observeMonth(block);
      }, { passive: true });
    });
  </script>
</body>
</html>
