<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>archive</title>
  <meta name="format-detection" content="telephone=no, date=no, address=no, email=no">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>
    * { box-sizing: border-box; }

    :root{
      /* Desktop knobs */
      --left-gutter: 36px;     /* small home-icon gutter */
      --right-gutter: 96px;    /* visible whitespace on the right */
      --content-pad: 24px;

      /* Mobile knobs */
      --mobile-side-pad: 14px; /* smaller padding => bigger images */
      --mobile-top-pad: 12px;
      --icon-size: 26px;

      /* ✅ Gap between icon and month header (mobile only) */
      --mobile-icon-gap: 10px;
    }

    body{
      font-family: Arial, Helvetica, sans-serif;
      font-size: 11px;
      margin: 0;
      padding: 0;
      background: white;
      color: black;
      overflow-x: hidden;
    }

    /* ───────────── Home icon base ───────────── */
    .home-icon{
      width: var(--icon-size);
      height: var(--icon-size);
      opacity: 0.95;
      -webkit-tap-highlight-color: transparent;
      display: inline-block;
    }
    .home-icon img{
      width: 100%;
      height: auto;
      display: block;
    }
    .home-icon:hover{ opacity: 1; }

    /* ───────────── Mobile-only top area (non-sticky icon) ───────────── */
    .mobile-top{
      position: relative;
      padding-top: var(--mobile-top-pad);
      padding-left: var(--mobile-side-pad);
      padding-right: var(--mobile-side-pad);
      height: calc(var(--icon-size) + (var(--mobile-top-pad) * 2));
    }

    .home-icon--mobile{
      position: absolute;
      top: var(--mobile-top-pad);
      left: calc(env(safe-area-inset-left) + var(--mobile-side-pad));
    }

    /* ───────────── Desktop-only fixed icon (stays put on scroll) ───────────── */
    .home-icon--desktop{
      position: fixed;
      top: 16px;
      left: 8px;
      z-index: 1000;
    }

    /* Show/hide the right one by breakpoint */
    @media (min-width: 901px){
      .mobile-top{ display: none; }
    }
    @media (max-width: 900px){
      .home-icon--desktop{ display: none; }
    }

    /* ───────────── Content ───────────── */

    /* Mobile/tablet: centered, tighter padding for more image space */
    .content{
      margin: 0 auto;
      max-width: 700px;
      padding: 0 var(--mobile-side-pad) 2rem;
    }

    /* ✅ THE FIX: push content down on mobile so month header isn't hugging the icon */
    @media (max-width: 900px){
      .content{
        padding-top: var(--mobile-icon-gap);
      }
    }

    /* Desktop: old nav-era feel (content starts after left gutter) */
    @media (min-width: 900px){
      .content{
        margin: 0;
        max-width: none;
        padding: var(--content-pad);
        margin-left: var(--left-gutter);
      }
    }

    .full-post-block{
      margin-bottom: 4rem;
    }

    .date{
      font-size: 11px;
      color: #000000;
      margin-bottom: 0.5rem;
    }

    .post img,
    figure img{
      max-width: 100%;
      height: auto;
      margin-top: 1rem;
      display: block;
      opacity: 0;
      transition: opacity 0.6s ease;
      dynamic-range-limit: standard;
    }

    img.loaded{ opacity: 1; }

    figure{
      margin: 1rem 0;
      padding: 0;
    }

    .figure-row{
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      margin-top: 1rem;
      margin-bottom: 2rem;
    }

    .figure-row figure{
      flex: 1 1 30%;
      margin: 0;
    }

    .figure-row img{
      width: 100%;
      height: auto;
      object-fit: cover;
      display: block;
    }

    /* ───────────── Desktop: wide posts with right whitespace ───────────── */
    @media (min-width: 900px){
      .full-post-block{
        width: calc(100vw - var(--left-gutter) - var(--right-gutter));
        max-width: calc(100vw - var(--left-gutter) - var(--right-gutter));
      }

      .full-post-block > figure,
      .full-post-block p,
      .full-post-block .date{
        width: 100%;
        max-width: 100%;
      }
    }

    /* ───────────── Month grouping + toggle behavior ───────────── */
    .month-block{ margin-bottom: 3rem; }

    .month-header{
      background: none;
      border: none;
      padding: 0.5rem 0;
      font-size: 0.8rem;
      text-align: left;
      cursor: pointer;
      color: #000;
      width: 100%;
      -webkit-tap-highlight-color: transparent;
    }

    .month-header:hover{ color: #000000; }

    .month-header::before{
      content: "▸ ";
      display: inline-block;
      transition: transform 0.2s ease;
    }

    .month-block.expanded .month-header::before{
      transform: rotate(90deg);
    }

    .month-content{ margin-top: 0.75rem; }
    .month-block.collapsed .month-content{ display: none; }
  </style>
</head>

<body>

  <!-- Mobile-only non-sticky icon (scrolls away) -->
  <div class="mobile-top">
    <a class="home-icon home-icon--mobile" href="https://drakehooks.net" aria-label="Home">
      <img src="/drawing.svg" alt="">
    </a>
  </div>

  <!-- Desktop-only fixed icon (stays put on scroll) -->
  <a class="home-icon home-icon--desktop" href="https://drakehooks.net" aria-label="Home">
    <img src="/drawing.svg" alt="">
  </a>

  <div class="content">
    {{ range $idx, $month := .Pages.ByDate.Reverse.GroupByDate "01 2006" }}
      <section class="month-block {{ if eq $idx 0 }}expanded{{ else }}collapsed{{ end }}">
        <button class="month-header" type="button">
          {{ $month.Key }}
        </button>

        <div class="month-content">
          {{ range $month.Pages.ByDate.Reverse }}
            <div class="full-post-block">
              <div class="date">{{ .Date.Format "01 02 2006" }}</div>
              {{ .Content }}
            </div>
          {{ end }}
        </div>
      </section>
    {{ end }}
  </div>

<script>
  document.addEventListener("DOMContentLoaded", () => {
    const FADE_GAP_MS = 70; // tweak for “peaceful” cadence (0 = no gap)

    const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

    function stashSrc(img) {
      // Store original src once, then remove src for collapsed months
      if (!img) return;
      if (!img.dataset.src && img.getAttribute("src")) {
        img.dataset.src = img.getAttribute("src");
      }
    }

    function ensureSrc(img) {
      if (!img.getAttribute("src") && img.dataset.src) {
        img.setAttribute("src", img.dataset.src);
      }
    }

    function loadPromise(img) {
      // Resolve when the image is actually decodable/paintable
      if (img.complete && img.naturalWidth !== 0) return Promise.resolve();

      // Modern browsers: decode() waits until it can be rendered
      if (img.decode) {
        return img.decode().catch(() => {
          // decode can fail for cross-origin / timing reasons; fall back to load event
          return new Promise((resolve) => {
            img.addEventListener("load", resolve, { once: true });
            img.addEventListener("error", resolve, { once: true });
          });
        });
      }

      // Fallback
      return new Promise((resolve) => {
        img.addEventListener("load", resolve, { once: true });
        img.addEventListener("error", resolve, { once: true });
      });
    }

    async function revealInOrder(imgs) {
      // 1) Start ALL loads immediately (parallel)
      const promises = imgs.map((img) => {
        ensureSrc(img);
        return loadPromise(img);
      });

      // 2) Reveal strictly in DOM order (sequential)
      for (let i = 0; i < imgs.length; i++) {
        await promises[i];
        // ensure transition triggers reliably
        requestAnimationFrame(() => imgs[i].classList.add("loaded"));
        if (FADE_GAP_MS) await sleep(FADE_GAP_MS);
      }
    }

    // Wire initial expanded month: reveal sequentially in order
    const expanded = document.querySelector(".month-block.expanded");
    if (expanded) {
      const imgs = Array.from(expanded.querySelectorAll("img"));
      imgs.forEach(stashSrc);
      // keep their src (expanded month should show), but reveal in order
      revealInOrder(imgs);
    }

    // For collapsed months: stash and remove src so they don’t load early
    document.querySelectorAll(".month-block.collapsed img").forEach((img) => {
      stashSrc(img);
      img.removeAttribute("src");
      img.classList.remove("loaded"); // optional: keep hidden until expanded
    });

    document.addEventListener("click", (e) => {
      const header = e.target.closest(".month-header");
      if (!header) return;

      const block = header.closest(".month-block");
      const expanding = block.classList.contains("collapsed");

      block.classList.toggle("collapsed");
      block.classList.toggle("expanded");

      if (expanding) {
        const imgs = Array.from(block.querySelectorAll("img"));
        imgs.forEach(stashSrc);
        // If re-expanding, keep already-loaded ones visible; reveal the rest in order
        const toReveal = imgs.filter((img) => !img.classList.contains("loaded"));
        revealInOrder(toReveal);
      } else {
        // Optional behavior: if you want them to re-animate every time you expand:
        // block.querySelectorAll("img").forEach(img => img.classList.remove("loaded"));
        // (don’t remove src here unless you want to re-fetch on every expand)
      }
    });
  });
</script>

</body>
</html>
