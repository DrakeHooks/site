<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>archive</title>
  <meta name="format-detection" content="telephone=no, date=no, address=no, email=no">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>
    * { box-sizing: border-box; }

    :root{
      /* Desktop knobs */
      --left-gutter: 36px;
      --right-gutter: 96px;
      --content-pad: 24px;

      /* Mobile knobs */
      --mobile-side-pad: 14px;
      --mobile-top-pad: 12px;
      --icon-size: 26px;

      /* Gap between icon and month header (mobile only) */
      --mobile-icon-gap: 10px;

      /* Calm animation tuning */
      --fade-duration: 2400ms;
      --fade-ease: cubic-bezier(0.16, 1, 0.3, 1);
      --fade-start: 0.0;
      --fade-min-delay: 80ms;
      --fade-stagger: 55ms;
      --fade-stagger-cap: 600ms;

      /* Link hover grey */
      --link-hover-grey: #b5b5b5;
    }

    body{
      font-family: Arial, Helvetica, sans-serif;
      font-size: 11px;
      margin: 0;
      padding: 0;
      background: #FAFAF7;
      color: black;
      overflow-x: hidden;
    }

    /* ───────────── Links (safe: no background, no layout side effects) ───────────── */
    a,
    a:visited{
      color: inherit;
      text-decoration: underline;
      text-decoration-color: currentColor;
      text-decoration-thickness: 1px;
      text-underline-offset: 2px;
      -webkit-tap-highlight-color: transparent;
    }
    a:hover{
      color: var(--link-hover-grey);
      text-decoration-color: var(--link-hover-grey);
    }

    /* ───────────── Home icon base ───────────── */
    .home-icon{
      width: var(--icon-size);
      height: var(--icon-size);
      opacity: 0.95;
      -webkit-tap-highlight-color: transparent;
      display: inline-block;
    }
    .home-icon img{
      width: 100%;
      height: auto;
      display: block;
    }
    .home-icon:hover{ opacity: 1; }

    /* ───────────── Mobile-only top area (non-sticky icon) ───────────── */
    .mobile-top{
      position: relative;
      padding-top: var(--mobile-top-pad);
      padding-left: var(--mobile-side-pad);
      padding-right: var(--mobile-side-pad);
      height: calc(var(--icon-size) + (var(--mobile-top-pad) * 2));
    }

    .home-icon--mobile{
      position: absolute;
      top: var(--mobile-top-pad);
      left: calc(env(safe-area-inset-left) + var(--mobile-side-pad));
    }

    /* ───────────── Desktop-only fixed icon (stays put on scroll) ───────────── */
    .home-icon--desktop{
      position: fixed;
      top: 16px;
      left: 8px;
      z-index: 1000;
    }

    @media (min-width: 901px){ .mobile-top{ display: none; } }
    @media (max-width: 900px){ .home-icon--desktop{ display: none; } }

    /* ───────────── Content ───────────── */
    .content{
      margin: 0 auto;
      max-width: 700px;
      padding: 0 var(--mobile-side-pad) 2rem;
    }

    @media (max-width: 900px){
      .content{ padding-top: var(--mobile-icon-gap); }
    }

    @media (min-width: 900px){
      .content{
        margin: 0;
        max-width: none;
        padding: var(--content-pad);
        margin-left: var(--left-gutter);
      }
    }

    /* BIG FPS WIN:
       Skip painting/layout of offscreen posts/figures while scrolling long pages.
       contain-intrinsic-size reserves a cheap placeholder size. */
    .full-post-block{
      margin-bottom: 4rem;
      contain: layout paint;
      content-visibility: auto;
      contain-intrinsic-size: 1200px 900px; /* tweak if your posts are usually taller/shorter */
    }

    figure{
      margin: 1rem 0;
      padding: 0;
      contain: layout paint;
      content-visibility: auto;
      contain-intrinsic-size: 900px 700px;
    }

    .date{
      font-size: 11px;
      color: #000000; /* keep black */
      margin-bottom: 0.5rem;
    }

    /* ───────────── Calm sequential fade ───────────── */
    .post img,
    figure img{
      max-width: 100%;
      height: auto;
      margin-top: 1rem;
      display: block;

      opacity: var(--fade-start);
      transition-property: opacity;
      transition-duration: var(--fade-duration);
      transition-timing-function: var(--fade-ease);
      transition-delay: var(--fade-delay, 0ms);

      dynamic-range-limit: standard;
    }

    /* Only while fading (kept short via JS) */
    img.fading{
      will-change: opacity;
    }

    img.reveal{
      opacity: 1;
    }

    img.broken{
      opacity: 1;
      filter: grayscale(1);
    }

    .figure-row{
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      margin-top: 1rem;
      margin-bottom: 2rem;
      contain: layout paint;
      content-visibility: auto;
      contain-intrinsic-size: 700px 500px;
    }

    .figure-row figure{
      flex: 1 1 30%;
      margin: 0;
      content-visibility: auto;
      contain-intrinsic-size: 500px 400px;
    }

    .figure-row img{
      width: 100%;
      height: auto;
      object-fit: cover;
      display: block;
    }

    /* ───────────── Desktop: wide posts with right whitespace ───────────── */
    @media (min-width: 900px){
      .full-post-block{
        width: calc(100vw - var(--left-gutter) - var(--right-gutter));
        max-width: calc(100vw - var(--left-gutter) - var(--right-gutter));
      }

      .full-post-block > figure,
      .full-post-block p,
      .full-post-block .date{
        width: 100%;
        max-width: 100%;
      }
    }

    /* ───────────── Month grouping + toggle behavior ───────────── */
    .month-block{ margin-bottom: 3rem; }

    .month-header{
      background: none;
      border: none;
      padding: 0.5rem 0;
      font-size: 0.8rem;
      text-align: left;
      cursor: pointer;
      color: #000; /* fixes Firefox “blue” */
      width: 100%;
      -webkit-tap-highlight-color: transparent;
    }

    .month-header:hover{ color: #000000; }

    .month-header::before{
      content: "▸ ";
      display: inline-block;
      transition: transform 0.2s ease;
    }

    .month-block.expanded .month-header::before{
      transform: rotate(90deg);
    }

    .month-content{ margin-top: 0.75rem; }
    .month-block.collapsed .month-content{ display: none; }

    @media (prefers-reduced-motion: reduce){
      .post img, figure img { transition: none; opacity: 1; }
    }
  </style>
</head>

<body>

  <div class="mobile-top">
    <a class="home-icon home-icon--mobile" href="https://drakehooks.net" aria-label="Home">
      <img src="/drawing.svg" alt="">
    </a>
  </div>

  <a class="home-icon home-icon--desktop" href="https://drakehooks.net" aria-label="Home">
    <img src="/drawing.svg" alt="">
  </a>

  <div class="content">
    {{ range $idx, $month := .Pages.ByDate.Reverse.GroupByDate "01 2006" }}
      <section class="month-block {{ if eq $idx 0 }}expanded{{ else }}collapsed{{ end }}">
        <button class="month-header" type="button">
          {{ $month.Key }}
        </button>

        <div class="month-content">
          {{ range $month.Pages.ByDate.Reverse }}
            <div class="full-post-block">
              <div class="date">{{ .Date.Format "01 02 2006" }}</div>
              {{ .Content }}
            </div>
          {{ end }}
        </div>
      </section>
    {{ end }}
  </div>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      function primeImg(img, eager=false, high=false) {
        if (!img) return;
        if (!img.hasAttribute("decoding")) img.setAttribute("decoding", "async");
        if (!img.hasAttribute("loading"))  img.setAttribute("loading", eager ? "eager" : "lazy");
        if (high && !img.hasAttribute("fetchpriority")) img.setAttribute("fetchpriority", "high");
      }

      function markBroken(img) {
        img.classList.add("broken");
      }

      // Cache fade params ONCE (avoid getComputedStyle work every reveal batch)
      const rootStyle = getComputedStyle(document.documentElement);
      const MIN_DELAY = parseInt(rootStyle.getPropertyValue("--fade-min-delay")) || 80;
      const STEP      = parseInt(rootStyle.getPropertyValue("--fade-stagger")) || 55;
      const CAP       = parseInt(rootStyle.getPropertyValue("--fade-stagger-cap")) || 600;

      // Batch reveal in 1 rAF
      const revealQueue = [];
      let revealRAF = 0;

      function scheduleReveal(img) {
        if (!img || img.classList.contains("reveal") || img.classList.contains("broken")) return;
        if (img.dataset._queued === "1") return;
        img.dataset._queued = "1";
        revealQueue.push(img);

        if (revealRAF) return;
        revealRAF = requestAnimationFrame(() => {
          revealRAF = 0;

          // Fast sort by numeric index (no expensive DOM position comparisons)
          revealQueue.sort((a, b) => {
            const ai = (a.dataset._idx|0);
            const bi = (b.dataset._idx|0);
            return ai - bi;
          });

          for (let i = 0; i < revealQueue.length; i++) {
            const im = revealQueue[i];
            im.dataset._queued = "0";

            const d = MIN_DELAY + Math.min(i * STEP, CAP);
            im.style.setProperty("--fade-delay", d + "ms");

            // Only keep will-change while the fade is actually happening
            im.classList.add("fading");
            im.classList.add("reveal");
          }

          revealQueue.length = 0;
        });
      }

      // Remove will-change after the transition completes (prevents keeping tons of layers alive)
      function attachFadeCleanup(img) {
        if (img.dataset._fadeCleanup === "1") return;
        img.dataset._fadeCleanup = "1";
        img.addEventListener("transitionend", (e) => {
          if (e.propertyName !== "opacity") return;
          img.classList.remove("fading");
        }, { passive: true });
      }

      // IntersectionObserver: reveal when in-view-ish
      const io = new IntersectionObserver((entries) => {
        for (const e of entries) {
          if (!e.isIntersecting) continue;
          const img = e.target;

          io.unobserve(img);
          img.dataset._shouldReveal = "1";

          if (img.complete) {
            if (img.naturalWidth === 0) { markBroken(img); continue; }
            scheduleReveal(img);
          }
        }
      }, {
        root: null,
        rootMargin: "140px 0px",
        threshold: 0.01
      });

      function attachHandlers(img) {
        if (!img || img.dataset._handlers === "1") return;
        img.dataset._handlers = "1";

        attachFadeCleanup(img);

        img.addEventListener("load", () => {
          if (img.naturalWidth === 0) { markBroken(img); return; }
          if (img.dataset._shouldReveal === "1") scheduleReveal(img);
        }, { passive: true });

        img.addEventListener("error", () => markBroken(img), { passive: true });
      }

      // Assign stable numeric indices so batching order is cheap
      let globalImgIdx = 1;

      function observeMonth(block) {
        const imgs = Array.from(block.querySelectorAll("img"));

        for (let i = 0; i < imgs.length; i++) {
          const img = imgs[i];

          // Give a numeric, stable ordering key (once)
          if (!img.dataset._idx) img.dataset._idx = String(globalImgIdx++);

          const top = i < 2;
          primeImg(img, top, top);
          attachHandlers(img);

          // IMPORTANT PERF CHANGE:
          // Don't reset already-revealed images on expand.
          // Resetting lots of nodes = needless style/layout work.
          if (!img.classList.contains("reveal") && !img.classList.contains("broken")) {
            img.style.removeProperty("--fade-delay");
            img.dataset._shouldReveal = "0";
            io.observe(img);
          }
        }
      }

      // Initial expanded month
      const initiallyExpanded = document.querySelector(".month-block.expanded");
      if (initiallyExpanded) observeMonth(initiallyExpanded);

      // Toggle handler
      document.addEventListener("click", (e) => {
        const header = e.target.closest(".month-header");
        if (!header) return;

        const block = header.closest(".month-block");
        if (!block) return;

        const expanding = block.classList.contains("collapsed");
        block.classList.toggle("collapsed");
        block.classList.toggle("expanded");

        if (expanding) observeMonth(block);
      }, { passive: true });
    });
  </script>

</body>
</html>
