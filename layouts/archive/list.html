<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>archive</title>
  <meta name="format-detection" content="telephone=no, date=no, address=no, email=no">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>
    * { box-sizing: border-box; }

    :root{
      /* Desktop knobs */
      --left-gutter: 36px;
      --right-gutter: 96px;
      --content-pad: 24px;

      /* Mobile knobs */
      --mobile-side-pad: 14px;
      --mobile-top-pad: 12px;
      --icon-size: 26px;

      /* Gap between icon and month header (mobile only) */
      --mobile-icon-gap: 10px;
    }

    body{
      font-family: Arial, Helvetica, sans-serif;
      font-size: 11px;
      margin: 0;
      padding: 0;
      background: white;
      color: black;
      overflow-x: hidden;
    }

    /* ───────────── Home icon base ───────────── */
    .home-icon{
      width: var(--icon-size);
      height: var(--icon-size);
      opacity: 0.95;
      -webkit-tap-highlight-color: transparent;
      display: inline-block;
    }
    .home-icon img{
      width: 100%;
      height: auto;
      display: block;
    }
    .home-icon:hover{ opacity: 1; }

    /* ───────────── Mobile-only top area (non-sticky icon) ───────────── */
    .mobile-top{
      position: relative;
      padding-top: var(--mobile-top-pad);
      padding-left: var(--mobile-side-pad);
      padding-right: var(--mobile-side-pad);
      height: calc(var(--icon-size) + (var(--mobile-top-pad) * 2));
    }

    .home-icon--mobile{
      position: absolute;
      top: var(--mobile-top-pad);
      left: calc(env(safe-area-inset-left) + var(--mobile-side-pad));
    }

    /* ───────────── Desktop-only fixed icon (stays put on scroll) ───────────── */
    .home-icon--desktop{
      position: fixed;
      top: 16px;
      left: 8px;
      z-index: 1000;
    }

    @media (min-width: 901px){
      .mobile-top{ display: none; }
    }
    @media (max-width: 900px){
      .home-icon--desktop{ display: none; }
    }

    /* ───────────── Content ───────────── */
    .content{
      margin: 0 auto;
      max-width: 700px;
      padding: 0 var(--mobile-side-pad) 2rem;
    }

    @media (max-width: 900px){
      .content{
        padding-top: var(--mobile-icon-gap);
      }
    }

    @media (min-width: 900px){
      .content{
        margin: 0;
        max-width: none;
        padding: var(--content-pad);
        margin-left: var(--left-gutter);
      }
    }

    .full-post-block{
      margin-bottom: 4rem;

      /*
        content-visibility is still the biggest overall win, but "waking" elements can be
        janky if the intrinsic size estimate is too small. A larger estimate usually
        makes upward scrolling smoother (less relayout churn).
      */
      content-visibility: auto;
      contain-intrinsic-size: 1px 1400px;

      /* isolates layout/paint to reduce cascading invalidations */
      contain: layout paint;
    }

    .date{
      font-size: 11px;
      color: #000000;
      margin-bottom: 0.5rem;
    }

    .post img,
    figure img{
      max-width: 100%;
      height: auto;
      margin-top: 1rem;
      display: block;

      opacity: 0;
      transition: opacity 0.6s ease;

      /* IMPORTANT: keep will-change OFF globally */
      dynamic-range-limit: standard;
    }

    img.loaded{ opacity: 1; }

    img.broken{
      opacity: 1;
      filter: grayscale(1);
    }

    figure{
      margin: 1rem 0;
      padding: 0;
      contain: layout paint;
    }

    .figure-row{
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      margin-top: 1rem;
      margin-bottom: 2rem;
      contain: layout paint;
    }

    .figure-row figure{
      flex: 1 1 30%;
      margin: 0;
    }

    .figure-row img{
      width: 100%;
      height: auto;
      object-fit: cover;
      display: block;
    }

    /* ───────────── Desktop: wide posts with right whitespace ───────────── */
    @media (min-width: 900px){
      .full-post-block{
        width: calc(100vw - var(--left-gutter) - var(--right-gutter));
        max-width: calc(100vw - var(--left-gutter) - var(--right-gutter));
      }

      .full-post-block > figure,
      .full-post-block p,
      .full-post-block .date{
        width: 100%;
        max-width: 100%;
      }
    }

    /* ───────────── Month grouping + toggle behavior ───────────── */
    .month-block{ margin-bottom: 3rem; }

    .month-header{
      background: none;
      border: none;
      padding: 0.5rem 0;
      font-size: 0.8rem;
      text-align: left;
      cursor: pointer;
      color: #000;
      width: 100%;
      -webkit-tap-highlight-color: transparent;
    }

    .month-header:hover{ color: #000000; }

    .month-header::before{
      content: "▸ ";
      display: inline-block;
      transition: transform 0.2s ease;
    }

    .month-block.expanded .month-header::before{
      transform: rotate(90deg);
    }

    .month-content{ margin-top: 0.75rem; }
    .month-block.collapsed .month-content{ display: none; }
  </style>
</head>

<body>

  <!-- Mobile-only non-sticky icon (scrolls away) -->
  <div class="mobile-top">
    <a class="home-icon home-icon--mobile" href="https://drakehooks.net" aria-label="Home">
      <img src="/drawing.svg" alt="">
    </a>
  </div>

  <!-- Desktop-only fixed icon (stays put on scroll) -->
  <a class="home-icon home-icon--desktop" href="https://drakehooks.net" aria-label="Home">
    <img src="/drawing.svg" alt="">
  </a>

  <div class="content">
    {{ range $idx, $month := .Pages.ByDate.Reverse.GroupByDate "01 2006" }}
      <section class="month-block {{ if eq $idx 0 }}expanded{{ else }}collapsed{{ end }}">
        <button class="month-header" type="button">
          {{ $month.Key }}
        </button>

        <div class="month-content">
          {{ range $month.Pages.ByDate.Reverse }}
            <div class="full-post-block">
              <div class="date">{{ .Date.Format "01 02 2006" }}</div>
              {{ .Content }}
            </div>
          {{ end }}
        </div>
      </section>
    {{ end }}
  </div>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const raf = () => new Promise(requestAnimationFrame);

      const ric = window.requestIdleCallback
        ? (fn) => window.requestIdleCallback(fn, { timeout: 800 })
        : (fn) => setTimeout(() => fn({ timeRemaining: () => 0, didTimeout: true }), 1);

      // ---- Idle decode queue (scroll always wins) ----
      const decodeQueue = [];
      let decodeScheduled = false;

      function scheduleDecode(img) {
        if (!img) return;
        if (img.dataset._decodeQueued === "1") return;
        img.dataset._decodeQueued = "1";
        decodeQueue.push(img);

        if (!decodeScheduled) {
          decodeScheduled = true;
          ric(runDecodeQueue);
        }
      }

      function runDecodeQueue(deadline) {
        let n = 0;
        while (decodeQueue.length) {
          const img = decodeQueue.shift();
          if (!img) continue;

          // Skip if already visible or broken
          if (img.classList.contains("loaded") || img.classList.contains("broken")) continue;

          // If not restored yet, we can't meaningfully decode it
          if (img.dataset._restored !== "1") continue;

          // If it's already complete but failed, ignore
          if (img.complete && img.naturalWidth === 0) continue;

          // Fire decode without awaiting; keep it background
          if (img.decode) img.decode().catch(() => {});

          n++;
          if (deadline && deadline.timeRemaining && deadline.timeRemaining() < 6) break;
          if (n >= 10) break;
        }

        decodeScheduled = false;
        if (decodeQueue.length) {
          decodeScheduled = true;
          ric(runDecodeQueue);
        }
      }

      // ---- Viewport pre-decode (helps scroll up + down) ----
      const io = ("IntersectionObserver" in window)
        ? new IntersectionObserver((entries) => {
            for (const entry of entries) {
              if (!entry.isIntersecting) continue;
              const img = entry.target;
              // Decode "near" viewport in idle time so when you hit it (esp scrolling up)
              // it’s already warm.
              scheduleDecode(img);
            }
          }, {
            root: null,
            // Large margin both directions so we prep images before you reach them
            rootMargin: "1400px 0px 1400px 0px",
            threshold: 0.01
          })
        : null;

      function observeImgs(container) {
        if (!io) return;
        container.querySelectorAll("img").forEach(img => io.observe(img));
      }

      // ---- Image attribute stashing (supports src/srcset/sizes) ----
      function stashImg(img) {
        if (!img || img.dataset._stashed === "1") return;

        if (img.getAttribute("src"))    img.dataset.src = img.getAttribute("src");
        if (img.getAttribute("srcset")) img.dataset.srcset = img.getAttribute("srcset");
        if (img.getAttribute("sizes"))  img.dataset.sizes = img.getAttribute("sizes");

        img.removeAttribute("src");
        img.removeAttribute("srcset");
        img.removeAttribute("sizes");

        img.dataset._stashed = "1";
      }

      function restoreImgAttrs(img) {
        if (!img || img.dataset._restored === "1") return;

        if (!img.hasAttribute("loading")) img.setAttribute("loading", "lazy");
        if (!img.hasAttribute("decoding")) img.setAttribute("decoding", "async");

        // Restore sizes/srcset first, then src
        if (!img.getAttribute("sizes") && img.dataset.sizes) {
          img.setAttribute("sizes", img.dataset.sizes);
        }
        if (!img.getAttribute("srcset") && img.dataset.srcset) {
          img.setAttribute("srcset", img.dataset.srcset);
        }
        if (!img.getAttribute("src") && img.dataset.src) {
          img.setAttribute("src", img.dataset.src);
        }

        img.dataset._restored = "1";

        // As soon as it’s restorable, start preparing decode in the background
        scheduleDecode(img);
      }

      // Wait for an image without ever hanging forever
      function waitForImg(img, timeoutMs = 12000) {
        return new Promise((resolve) => {
          if (img.complete) { resolve(); return; }

          let done = false;
          const finish = () => {
            if (done) return;
            done = true;
            cleanup();
            resolve();
          };

          const cleanup = () => {
            clearTimeout(tid);
            img.removeEventListener("load", finish);
            img.removeEventListener("error", finish);
          };

          img.addEventListener("load", finish, { once: true });
          img.addEventListener("error", finish, { once: true });
          const tid = setTimeout(finish, timeoutMs);
        });
      }

      // ---- Peaceful reveal: in-order, but NEVER blocks on decode ----
      async function revealInOrder(imgs) {
        for (let i = 0; i < imgs.length; i++) {
          const img = imgs[i];
          if (img.classList.contains("loaded") || img.classList.contains("broken")) continue;

          await waitForImg(img);

          // If it failed, don’t block the rest
          if (img.complete && img.naturalWidth === 0) {
            img.classList.add("broken");
            await raf();
            continue;
          }

          // IMPORTANT CHANGE:
          // Do NOT await decode here. Just schedule it in idle time.
          scheduleDecode(img);

          img.classList.add("loaded");
          await raf();
        }
      }

      function expandMonth(block) {
        if (!block) return;
        const imgs = Array.from(block.querySelectorAll("img"));

        // Prioritize the first couple
        for (let i = 0; i < Math.min(2, imgs.length); i++) {
          if (!imgs[i].hasAttribute("fetchpriority")) imgs[i].setAttribute("fetchpriority", "high");
          if (!imgs[i].hasAttribute("loading")) imgs[i].setAttribute("loading", "eager");
        }

        // Restore a small initial batch immediately
        imgs.slice(0, 12).forEach(restoreImgAttrs);

        // Reveal in order (safe even if some fail)
        revealInOrder(imgs);

        // Restore the rest in idle chunks
        let idx = 12;
        const chunkSize = 20;

        function idleChunk(deadline) {
          const start = idx;
          while (idx < imgs.length) {
            restoreImgAttrs(imgs[idx]);
            idx++;

            if (deadline && deadline.timeRemaining && deadline.timeRemaining() < 6) break;
            if ((idx - start) >= chunkSize) break;
          }
          if (idx < imgs.length) ric(idleChunk);
        }

        ric(idleChunk);

        // Make sure we’re pre-decoding near viewport for this month too
        observeImgs(block);
      }

      // ---- Initial setup ----
      // Stash images for months that start collapsed.
      document.querySelectorAll(".month-block.collapsed img").forEach(stashImg);

      // Observe anything already in the DOM (initial expanded month)
      observeImgs(document);

      // For initially expanded month: set defaults + reveal in order
      const initiallyExpanded = document.querySelector(".month-block.expanded");
      if (initiallyExpanded) {
        const imgs = Array.from(initiallyExpanded.querySelectorAll("img"));

        imgs.forEach((img, i) => {
          img.dataset._restored = "1"; // already has attrs in HTML
          if (!img.hasAttribute("loading")) img.setAttribute("loading", i < 2 ? "eager" : "lazy");
          if (!img.hasAttribute("decoding")) img.setAttribute("decoding", "async");
          if (i < 2 && !img.hasAttribute("fetchpriority")) img.setAttribute("fetchpriority", "high");
          scheduleDecode(img);
        });

        revealInOrder(imgs);
      }

      // ---- Toggle handler ----
      document.addEventListener("click", (e) => {
        const header = e.target.closest(".month-header");
        if (!header) return;

        const block = header.closest(".month-block");
        if (!block) return;

        const expanding = block.classList.contains("collapsed");

        block.classList.toggle("collapsed");
        block.classList.toggle("expanded");

        // Keep images loaded/cached on collapse. Only do work on expand.
        if (expanding) expandMonth(block);
      }, { passive: true });
    });
  </script>

</body>
</html>
